"""
Risk Gate Protocol for Portfolio-Level Risk Management.

Design principles:
- Risk gates evaluate signals against portfolio-level constraints
- Can approve, modify, or reject signals
- Rejection/modification reasons are tracked for post-hoc analysis
- Keeps risk logic out of individual strategies

Inspired by LEAN's IRiskManagementModel but with Protocol composition.

"""

from dataclasses import dataclass
from datetime import datetime
from typing import TYPE_CHECKING, List, Literal, Optional, Protocol

from .signal import Signal

if TYPE_CHECKING:
    from ..portfolio.event_ledger import EventLedger, LedgerPosition


RiskGateAction = Literal["approved", "modified", "rejected"]


@dataclass(frozen=True)
class RiskGateResult:
    """
    Result of risk gate evaluation.

    Attributes
    ----------
    signal : Signal, optional
        The signal to execute. None if rejected, possibly modified if action="modified".
    action : RiskGateAction
        What the risk gate did: approved (unchanged), modified, or rejected.
    reason : str, optional
        Human-readable explanation for modification/rejection.
    """

    signal: Optional[Signal]
    action: RiskGateAction
    reason: Optional[str] = None

    def __post_init__(self):
        # Validate consistency
        if self.action == "rejected" and self.signal is not None:
            raise ValueError("Rejected result should have signal=None")
        if self.action in ("approved", "modified") and self.signal is None:
            raise ValueError(f"{self.action} result requires a signal")


@dataclass(frozen=True)
class RiskGateEvent:
    """
    Record of a risk gate evaluation for debugging/analysis.

    Attributes
    ----------
    timestamp : datetime
        When the evaluation occurred
    original_signal : Signal
        The signal as generated by the strategy
    result : RiskGateResult
        What the risk gate decided
    """

    timestamp: datetime
    original_signal: Signal
    result: RiskGateResult


class RiskGate(Protocol):
    """
    Protocol for portfolio-level risk evaluation.

    Implementations can check:
    - Position count limits
    - Drawdown kill switches
    - Sector/strategy concentration
    - Max position sizes
    - Correlation limits
    - etc.

    Risk gates should be stateless - all context is passed in.
    """

    def evaluate(
        self,
        signal: Signal,
        open_positions: List["LedgerPosition"],
        equity: float,
        ledger: "EventLedger",
    ) -> RiskGateResult:
        """
        Evaluate a signal against risk constraints.

        Parameters
        ----------
        signal : Signal
            The signal to evaluate
        open_positions : List[LedgerPosition]
            Current open positions
        equity : float
            Current portfolio equity
        ledger : EventLedger
            Full ledger for detailed queries (P&L, history, etc.)

        Returns
        -------
        RiskGateResult
            - signal=original, action="approved" to pass through unchanged
            - signal=modified, action="modified" to adjust (e.g., reduce size)
            - signal=None, action="rejected" to block
        """
        ...


# =============================================================================
# Helper Functions
# =============================================================================


def approve(signal: Signal) -> RiskGateResult:
    """Convenience: approve signal unchanged."""
    return RiskGateResult(signal=signal, action="approved")


def reject(reason: str) -> RiskGateResult:
    """Convenience: reject signal with reason."""
    return RiskGateResult(signal=None, action="rejected", reason=reason)


def modify(signal: Signal, reason: str) -> RiskGateResult:
    """Convenience: approve modified signal with reason."""
    return RiskGateResult(signal=signal, action="modified", reason=reason)
