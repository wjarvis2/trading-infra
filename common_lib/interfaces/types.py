"""
Common data types used throughout the trading system.
"""
from dataclasses import dataclass
from datetime import datetime
from typing import Optional, Dict, Any
from decimal import Decimal
from enum import Enum


class Side(Enum):
    """Trade side."""
    BUY = "BUY"
    SELL = "SELL"


class OrderType(Enum):
    """Order type."""
    MARKET = "MARKET"
    LIMIT = "LIMIT"
    STOP = "STOP"
    STOP_LIMIT = "STOP_LIMIT"


class OrderStatus(Enum):
    """Order status."""
    PENDING = "PENDING"      # Waiting for market data
    SUBMITTED = "SUBMITTED"  # Sent to market/exchange
    PARTIAL = "PARTIAL"      # Partially filled
    FILLED = "FILLED"        # Completely filled
    CANCELLED = "CANCELLED"  # Explicitly cancelled by user
    REJECTED = "REJECTED"    # Rejected by broker/exchange
    EXPIRED = "EXPIRED"      # Timed out waiting for execution


@dataclass
class Bar:
    """OHLCV bar data."""
    timestamp: datetime
    symbol: str
    open: float
    high: float
    low: float
    close: float
    volume: int
    open_interest: Optional[int] = None
    
    @property
    def mid(self) -> float:
        """Mid price."""
        return (self.high + self.low) / 2


@dataclass
class Signal:
    """Trading signal generated by a strategy."""
    timestamp: datetime
    strategy_id: str
    symbol: str
    side: Side
    strength: float  # Expected return
    confidence: float  # 0-1
    size_hint: Optional[int] = None  # Suggested position size
    metadata: Optional[Dict[str, Any]] = None
    
    def __post_init__(self):
        if not 0 <= self.confidence <= 1:
            raise ValueError(f"Confidence must be between 0 and 1, got {self.confidence}")


@dataclass
class Order:
    """Order representation."""
    order_id: str
    timestamp: datetime
    symbol: str
    side: Side
    quantity: int
    order_type: OrderType
    limit_price: Optional[float] = None
    stop_price: Optional[float] = None
    time_in_force: str = "DAY"
    status: OrderStatus = OrderStatus.PENDING
    filled_quantity: int = 0
    average_fill_price: Optional[float] = None
    metadata: Optional[Dict[str, Any]] = None
    submission_time: Optional[datetime] = None  # When order entered pending queue


@dataclass
class Fill:
    """Execution fill."""
    fill_id: str
    order_id: str
    timestamp: datetime
    symbol: str
    side: Side
    quantity: int
    price: float
    commission: float
    liquidity_flag: Optional[str] = None  # MAKER/TAKER
    metadata: Optional[Dict[str, Any]] = None


@dataclass
class Position:
    """Current position."""
    symbol: str
    quantity: int  # Positive for long, negative for short
    average_price: float
    market_price: float
    unrealized_pnl: float
    realized_pnl: float
    timestamp: datetime
    
    @property
    def market_value(self) -> float:
        """Current market value."""
        return abs(self.quantity) * self.market_price
    
    @property
    def is_long(self) -> bool:
        """Check if position is long."""
        return self.quantity > 0
    
    @property
    def is_short(self) -> bool:
        """Check if position is short."""
        return self.quantity < 0


@dataclass
class PortfolioState:
    """Portfolio state snapshot."""
    timestamp: datetime
    cash: float
    positions: Dict[str, Position]
    total_equity: float
    margin_used: float
    buying_power: float
    
    @property
    def position_count(self) -> int:
        """Number of open positions."""
        return len([p for p in self.positions.values() if p.quantity != 0])
    
    @property
    def gross_exposure(self) -> float:
        """Total absolute market value of positions."""
        return sum(p.market_value for p in self.positions.values())

